http://linux.vbird.org/
1包含文件：
source 文件
2设置环境变量
setenv 变量名 值
3取得输入参数
第一个$1
第二个$2
4取得输入参数个数
$#argv
5打印:
echo “XXXXXX”
6正常结束
exit(0)
7异常结束
exit(1)
8定义变量
set 变量名=XXXXXX
9调用变量
$变量名 DD调用程序变量
${变量名}DD调用环境变量
10调用sql
参考/db/oracle/callsql.sh
11分支语句
if (a==b) then
XXXX
else
  XXXX
endif
12循环语句
#!/bin/csh
set str = "aaa bbb ccc ddd"
foreach str_temp ($str)
    echo $ str_temp
end
#!/bin/sh
for i in `seq 5`
do
  echo $i
done

for str in bbb ccc ddd
do
  echo $str
done

COUNTER=0
while [ $COUNTER -lt 5 ] 
do
	COUNTER=`expr $COUNTER + 1`
	echo $COUNTER
done

COUNTER=0
until [ $COUNTER -gt 5 ] 
do
	COUNTER=`expr $COUNTER + 1`
	echo $COUNTER
done  
13别名
alias  变量名 ‘字符串’
注意：字符串用“\!*”表示一个可传入的参数，
例：alias print 'echo \!*'
    print hello,world
14分step
程序名_STP01:
set stepName =程序名_STP01
'echo \!* `date "+%Y/%m/%d %H:%M:%S"` STEP-START'
XXXXX
'echo \!* `date "+%Y/%m/%d %H:%M:%S"` STEP-END'
15``和$()
  命令行调用``或$()，$()中可以包含``

16.shell连接sybase
source /opt/sybclient-15.0/sybash.sh
rs=`isql -S ** -U ** -P ** <<EOF
use datebase
go
...
...
go
quit
EOF`
echo $rs
注：EOF中间每行前面不能有空格

17.linux支持的语系
locale -a
默认语系
/etc/sysconfig/i18n

18.shell变量定义
declare [-aixr] ***
-a	array
-i	integer
-x	环境
-r	只读

19.删除字符串
删除最短数据
${变量#关键字}
例${PATH#/*:}

删除最长数据
${变量}##/*:}
例${PATH##/*:}

从尾部删除最短数据
${变量%关键字}
例${PATH%:*bin}

从尾部删除最长数据
${变量%%关键字}
例${PATH%%:*bin}

20.替换字符串
替换一个字符串
${变量/新字符/旧字符}
替换多个字符串
${变量//新字符/旧字符}

21.判断字符串
			str没有设置		str空			str已设置非空
var=${str-expr}		var=expr		var=			var=$str
var=${str:-expr}	var=expr		var=expr		var=$str
var=${str+expr}		var=			var=expr		var=expr
var=${str:+expr}	var=			var=			var=expr
var=${str=expr}		str=expr;var=expr	str不变;var=		str不变;var=$str
var=${str:=expr}	str=expr;var=expr	str=expr;var=expr	str不变;var=$str
var=${str?expr}		expr输出至stderr	var=			var=$srt
var=${str:?expr}	expr输出至stderr	expr输出至stderr	var=$srt

22.别名
alias	unalias

23.bash登录与欢迎信息
/etc/issue	/etc/motd

24.bash环境配置文件
/etc/profile	整体设置，不要修改
~/.bash_profile	~/.bash_login	~/.profile	个人配置文件

25.set设置
set -u	若使用未定义变量时，则显示错误信息
set -v	执行前，显示该命令内容，用于调试

26.数据流重定向
输出
find /home -name .bashrc > list_right 2 > list_error
不显示错误信息
find /home -name .bashrc 2 > /dev/null
全部写入
find /home -name .bashrc > list 2 > &1
find /home -name .bashrc &> list		同上

输入
复制.bashrc->catfile
cat > catfile < ~/.bashrc
输入"eof"结束
cat > catfile <<"eof"

27.命令执行的判定
ls /temp/abc || mkdir /temp/abc && touch /tmp/abc/hehe
ls /temp/vbirding && echo "exist" || echo "not exist"

28.管道命令
例: ls -al /etc | less

29.cut
echo $PATH | cut -d':' -f1,3
$PATH以':'分割，列出第一和第三个

export | cut -c12-
export排除第12列字符以前的

export | cut -c1-7
export第一到七个字符

last | cut -d' ' -f1
显示登录者信息，只留大名

30.grep
last | grep 'root'
列出root用户登录信息

last | grep -v 'root'
列出除root用户以外的用户登录信息

last | grep 'root' | cut -d ' ' -f1
列出root用户登录信息，只列大名

grep --color=auto 'MANPATH' /etc/man.config

31.sort
cat /etc/passwd | sort
cat /etc/passwd | sort -t':' -k3
按第三列排序
last | cut -d' ' -f1 | sort
取登录账号名并排序

32.uniq
last | cut -d' ' -f1 | sort | uniq
=group by
last | cut -d' ' -f1 | sort | uniq -c
列出重复次数（登录次数）

33.wc
cat /etc/man.config |wc
字，行，字节数

last | grep [a-zA-Z] | grep -v 'wtmp' | wc -l
系统登录总人数

34.双向重定向tee -a表示追加
last | tee last.list | cut -d " " -f1
将 last 的输出存一份到 last.list 档案中
ls -l /home | tee ~/homefile | more
将 ls 的资料存一份到 ~/homefile ，同时萤幕也有输出讯息
 ls -l / | tee -a ~/homefile | more
tee 后接的档案会被覆盖，所以，我们要加上 -a 这个参数才能将讯息累加

35.字符转换命令
tr:
last | tr '[a-z]' '[A-Z]'
大小写转换
cat /etc/passwd | tr -d':'
删除':'显示

36.col
cat /etc/man.config | col -x | cat -A | more
col -x	空格替换tab键
cat -A	显示特殊字符

37.join
join -t ':' -1 4 1.txt -2 3 2.txt
-1表示第一个文件1.txt
-2表示第二个文件2.txt
4表示第4列
3表示第3列
把第一个文件第4列和第二个文件第3列相同的列出来

38.paste
paste /etc/passwd /etc/shadow
cat /etc/group | paste /etc/passwd /etc/shadow -|head -n 3
-表示stdin

39.expand
    expand

@玩意壕褪窃 [tab] 按ID成空白I啦～可以@油妫

[root@www ~]# expand [-t] file
xc担
-t  ：後面可以接底帧Ｒ话碚f，一 tab 按I可以用 8 空白I取代。
      我也可以自行定x一 [tab] 按I代表多少字元呢！

例一： /etc/man.config 刃惺 MANPATH 的字泳腿〕觯H取前三行；
[root@www ~]# grep '^MANPATH' /etc/man.config | head -n 3
MANPATH /usr/man
MANPATH /usr/share/man
MANPATH /usr/local/man
# 行首的代表苏I ^ ，@我留待下介B！先有概念即可！

例二：承上，如果我想要⑺有的符都列出恚(用 cat)
[root@www ~]# grep '^MANPATH' /etc/man.config | head -n 3 |cat -A
MANPATH^I/usr/man$
MANPATH^I/usr/share/man$
MANPATH^I/usr/local/man$
# lF差e了幔]e～ [tab] 按I可以被 cat -A @示成 ^I 

例三：承上，我 [tab] 按IO定成 6 字元的？
[root@www ~]# grep '^MANPATH' /etc/man.config | head -n 3 | \
>  expand -t 6 - | cat -A
MANPATH     /usr/man$
MANPATH     /usr/share/man$
MANPATH     /usr/local/man$
123456123456123456.....
# 仔看一下上面的底终f明，因槲沂且 6 字元泶表一 [tab] 的L度，所以，
# MAN... 到 /usr 之g隔 12 ( [tab]) 字元喔！如果 tab 改成 9 的，
# 情r就又不同了！@e也不好理解～您可以多O定底聿殚就缘茫

expand 也是挺好玩的～他自 [tab] D成空白I～所以，以上面的例子碚f， 使用 cat -A 就查不到 ^I 的字符印此外，因 [tab] 最大的功能就是格式排列整R！ 我D成空白I後，@空白I也依我自己的定x碓黾哟笮　 所以，K不是一 ^I 就Q成 8 空白喔！@地方要特e注意的哩！ 此外，您也可以⒖家幌 unexpand @⒖瞻邹D成 [tab] 的指令功能

40.分割命令： split

如果你有n案太大，е乱恍y式b置o法}u的}，嘿嘿！找 split 就α耍 他可以湍⒁大n案，依n案大小或行矸指睿就可以⒋n案分割成樾n案了！ 快速又有效啊！真不e～

[root@www ~]# split [-bl] file PREFIX
xc担
-b  ：後面可接欲分割成的n案大小，可加挝唬例如 b, k, m 等；
-l  ：以行磉M行分割。
PREFIX ：代表前置字元的意思，可作榉指n案的前文字。

例一：我的 /etc/termcap 有七百多K，若想要分成 300K 一n案r？
[root@www ~]# cd /tmp; split -b 300k /etc/termcap termcap
[root@www tmp]# ll -k termcap*
-rw-r--r-- 1 root root 300 Feb  7 16:39 termcapaa
-rw-r--r-- 1 root root 300 Feb  7 16:39 termcapab
-rw-r--r-- 1 root root 189 Feb  7 16:39 termcapac
# 那n名可以S意取的啦！我只要上前文字，小n案就以
# xxxaa, xxxab, xxxac 等方式斫立小n案的！

例二：如何⑸厦娴娜小n案合成一n案，n名 termcapback
[root@www tmp]# cat termcap* >> termcapback
# 很伟桑烤陀觅Y料流重向就好啦！危

例三：使用 ls -al / 出的Y中，每十行成一n案
[root@www tmp]# ls -al / | split -l 10 - lsroot
[root@www tmp]# wc -l lsroot*
  10 lsrootaa
  10 lsrootab
   6 lsrootac
  26 total
# 重c在那 - 啦！一般碚f，如果需要 stdout/stdin r，但偏偏又]有n案，
# 有的只是 - r，那N那 - 就被成 stdin 或 stdout ～

在 Windows 作I系y下，你要n案分割需要如何作？X筋吧！在 Linux 底下就蔚亩嗔耍∧阋n案分割的，那N就使用 -b size ⒁分割的n案限制其大小，如果是行档脑，那N就使用 -l line 矸指睿『糜玫暮埽∪绱艘恚你就可以p易的⒛愕n案分割成碟 (floppy) 的大小，方便你 copy 樱

41.荡Q： xargs

xargs 是在做什N的呢？就以字面上的意x砜矗 x 是加p乘除的乘，args t是 arguments () 的意思，所以f，@玩意壕褪窃诋a生某指令的档囊馑迹 xargs 可以x入 stdin 的Y料，K且以空白字元或嘈凶衷作榉直妫 stdin 的Y料分隔成 arguments 。 因槭且钥瞻鬃衷作榉指簦所以，如果有一些n名或者是其他意x的名~群有空白字元的r候， xargs 可能就`判了～他的用法其也M蔚模【砜匆豢聪龋

[root@www ~]# xargs [-0epn] command
xc担
-0  ：如果入的 stdin 含有特殊字元，例如 `, \, 空白I等等字元r，@ -0 
      可以⑺原成一般字元。@悼梢杂渺短厥B喔！
-e  ：@是 EOF (end of file) 的意思。後面可以接一字串， xargs 分析到
      @字串r，就停止^m工作！
-p  ：在绦忻指令的 argument r，都使用者的意思；
-n  ：後面接次担每次 command 指令绦r，要使用档囊馑肌？垂例三。
 xargs 後面]有接任何的指令r，AO是以 echo 磉M行出喔！

例一： /etc/passwd 鹊牡谝谌〕觯H取三行，使用 finger @指令⒚
        ぬ热菪愠
[root@www ~]# cut -d':' -f1 /etc/passwd |head -n 3| xargs finger
Login: root                             Name: root
Directory: /root                        Shell: /bin/bash
Never logged in.
No mail.
No Plan.
......底下省略.....
# 由 finger account 可以取得ぬ的相Pf明热荩例如上面的出就是 finger root
# 後的Y果。在@例子中，我利用 cut 取出ぬ名Q，用 head 取出三ぬ，
# 最後t是由 xargs ⑷ぬ的名Q成 finger 後面需要的担

例二：同上，但是每次绦 finger r，都要使用者是否幼鳎
[root@www ~]# cut -d':' -f1 /etc/passwd |head -n 3| xargs -p finger
finger root bin daemon ?...y
.....(底下省略)....
# 呵呵！@ -p 的x可以使用者的使用^程中，被到每指令是否绦校

例三：⑺有的 /etc/passwd 鹊ぬ都以 finger 查，但一次H查五ぬ
[root@www ~]# cut -d':' -f1 /etc/passwd | xargs -p -n 5 finger
finger root bin daemon adm lp ?...y
.....(中g省略)....
finger uucp operator games gopher ftp ?...y
.....(底下省略)....
# 在@eB哥使用了 -p @碜您於 -n 更有概念。一般碚f，某些指令後面
# 可以接的 arguments 是有限制的，不能o限制的累加，此r，我可以利用 -n
# 椭我捣殖部分，每部分分e再以指令绦校∵@泳 OK 啦！^_^

例四：同上，但是分析到 lp 就Y束@串指令？
[root@www ~]# cut -d':' -f1 /etc/passwd | xargs -p -e'lp' finger
finger root bin daemon adm ?...
# 仔c上面的案例做比^。也同r注意，那 -e'lp' 是B在一起的，中g]有空白I。
# 上例子中，第五凳 lp 啊，那N我下_ -e'lp' 後，t分析到 lp
# @字串r，後面的其他 stdin 的热菥被 xargs 掉了！

其，在 man xargs e面就有三四小例，您可以自行⒖家幌热荨 此外， xargs 真的是很好用的一玩意海∧真的需要好好的⒃⒃！使用 xargs 的原因是， 很多指令其K不支援管命令，因此我可以透^ xargs 硖峁┰指令引用 standard input 之用！e例碚f，我使用如下的例碚f明：

例五：找出 /sbin 底下具有特殊嘞薜n名，K使用 ls -l 列出傩
[root@www ~]# find /sbin -perm +7000 | ls -l
# Y果竟然H有列出 root 所在目下的n案！@不是我要的！
# 因 ll (ls) K不是管命令的原因啊！

[root@www ~]# find /sbin -perm +7000 | xargs ls -l
-rwsr-xr-x 1 root root 70420 May 25  2008 /sbin/mount.nfs
-rwsr-xr-x 1 root root 70424 May 25  2008 /sbin/mount.nfs4
-rwxr-sr-x 1 root root  5920 Jun 15  2008 /sbin/netreport
....(底下省略)....


42.安全代码
IFs=$' \t\n'
unset -f unalias		#unalias -f 无效（函数）
unset -f command		#command -f 无效（函数）

SYSPATH="$(command -p getconf PATH 2>/dev/null)"
if [[ -z "$SYSPATH" ]];then
	SYSPATH="/usr/bin:/bin"
fi
PATH="$SYSPATH:$PATH"


43.删除第一行和最后一行
sed 1d file
sed $d file

44.bash调用bcp,isql
SYBASE_SH=sybase目录/SYBASE.sh
DATABASE="XXXX"
TABLE_NAME="XXXX"
SERVER-"XXXX"		#在Sybase安装目录下的interfaces文件
PASSWORD="XXXX"
#set log name
pid=$$
logName=$(basename $0)
logFile=/**/**/${logName}${pid}.log
echo "start"				                                >$logFile
if [ -e $SYBASE_SH ];then
	source $SYBASE_SH
else
	echo "Cannot find ${SYBASE_SH}"	                                >>$logFile
fi
if [ -e "bcp文件" ];then
	dataRows=$(grep -c "" bcp文件)   #统计行数
	bcp_rs=$(bcp ${DATABASE}.dbo.${TABLE_NAME} in bcp文件 -c -Jsjis -t"," -Y -S${SERVER} -U${USER} -P${PASSWORD})
	case ${bcp_rs} in
	*"${dataRows}"*"copied"*)
		echo "import succeeded:bcp文件${dataRows}rows"		>>$logFile
		;;
	*)
		echo "import failed:bcp文件"				>>$logFile
		echo $bcp_rs						>>$logFile
		exit 1;
		;;

	esac
fi

isql -S${SERVER} -U${USER} -P{PASSWORD}<<EOF
use $DATABASE
go
select ****
......
go
......
go
quit
EOF
rtnSql=$?
if [ $rtnSql -ne 0 ];then
	echo "deal with data with some error!!"				>>$logFile
fi

45循环目录文件
declare -a files    #数组定义
files=$(ls 目录)
for file in ${files[@]}
do
	....
done

46 读文件
while read -r line
do
	#cut
	outDataSub=$(expr shbstr "$line" 1 6)
	#split by ";"
	IFS=\;
	cols=($line)
	declare cols
	echo ${cols[0]}
	echo ${cols[1]}
	#IFS return space
	IFS=
	
	#trim
	convar=$(echo "${cols[1]}" | grep -o "[^ \t]\+\( \+[^ \t]\+\)*")
	echo $convar
	
	#output file
	echo ${cols[1]} >> $outputfile
done < *.txt

47 执行命令
``或$()

48 随机数
$RANDOM 0~32768
#随机0-9
decare -i number=$RANDOM*10/32768

49 键盘输入
read -p "提示语" -t 30 变量

50 定义数组
declare [-aixr] variable
 -a 数组
 -i 整数
 -x 环境变量，等于export
 -r readonly
 
50 取消环境变量，变成自定义变量
declare +x 变量

51 列出变量类型
declare -p 变量

52 set设定
set -u 变量使用前先定义
set -v 显示原始信息
set -x 执行前显示命令
set -C 文件存在时，使用>不覆盖

53 信息输出，错误输出
都输出文件
find /home -name .bashrc > list 2 > &1
find /home -name .bashrc & > list
丢弃错误信息
find /home -name .bashrc > list 2 > /dev/null

54 列切(cut)
cut -d '分隔字符' fields
cut -c 字符范围

55 行取(grep)
-a 将binary文件以text文件的方式查找
-C 计算找到次数
-i 忽略大小写
-n 行号
-v 反选
--color=auto 上色

55 排序(sort)
-f 忽略大小写
-b 忽略最前面空格
-n 纯数字排序
-M 月份名字排序
-r 反向
-u 合并相同
-t 分隔符，默认【Tab】
-k field排序，和-t一起使用

56 分组(uniq)
-i 忽略大小写
-C 进行计数

57 统计(wc)
-l 行数
-w 字数
-m 字符数

58 双向重定向（屏幕与文件）
tee

59 数字运算
$((运算))

60 运行参数
sh [-nvx] **.sh
-n 查语法
-v 执行前，显示到屏幕
-x 将使用到的script显示到屏幕

70 ftp
ftp -nv << ftpend > $ftp_log
	open $HOST
	user $USER_NAME $PASSWORD
	bin
	CD $DIR
	put XXX XXX
	bye
ftpend
#266 Transfer complete
egrep '^266' $ftp_log
put_end_sts=$?
#check cd error
grep "No such file or directory" $ftp_log
cd_end_sts=$?
if [ $put_end_sts != 0 ] || [ $cd_end_sts ==0 ]
then
	echo "ftp error"
fi



